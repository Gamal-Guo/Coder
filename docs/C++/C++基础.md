# C++基础

## 常见关键字

### const

**作用**

1. 修饰变量，说明该变量不可以被改变；
2. 修饰指针，分为指向常量的指针（pointer to const）和自身是常量的指针（常量指针，const pointer）；
3. 修饰引用，指向常量的引用（reference to const），用于形参类型，即避免了拷贝，又避免了函数对值的修改；
4. 修饰成员函数，说明该成员函数内不能修改成员变量。

**const 的指针与引用**

- 指针
  - 指向常量的指针（pointer to const）【`const int *p`;和`int const *p;` 二者等价】特点：const在*前面
  - 自身是常量的指针（常量指针，const pointer）【`int * const p;`】特点：const在*后面
- 引用
  - 指向常量的引用（reference to const）```const int & b = a;  *// 等价于int const & b = a;* ```
  - 没有 const reference，因为引用只是对象的别名，引用不是对象，不能用 const 修饰

**术语：**顶层const：表示指针本身是个常量；底层const：表示所指的对象是个常量。

### static

作用

1. 修饰普通变量，修改变量的存储区域和生命周期，使变量存储在静态区，在main函数运行前就分配了空间，如果有初始值就用初始值初始化它，如果没有初始值系统用默认值初始化它。
2. 修饰普通函数，表明函数的作用范围，仅在定义该函数的文件内才能使用。在多人开发项目时，为了防止与他人命名空间里的函数重名，可以将函数定位为static。
3. 修饰成员变量，修饰成员变量使所有的对象只保存一个该变量，而且不需要生成对象就可以访问该成员。
4. 修饰成员函数，修饰成员函数使得不需要生成对象就可以访问该函数，但是在static函数内不能访问非静态成员。

### this指针

1. `this` 指针是一个隐含于每一个非静态成员函数中的特殊指针。它指向调用该成员函数的那个对象。
2. 当对一个对象调用成员函数时，编译程序先将对象的地址赋给 `this` 指针，然后调用成员函数，每次成员函数存取数据成员时，都隐式使用 `this` 指针。
3. 当一个成员函数被调用时，自动向它传递一个隐含的参数，该参数是一个指向这个成员函数所在的对象的指针。
4. `this` 指针被隐含地声明为: `ClassName *const this`，此时this的类型是非常量版本的常量指针，这意味着不能给 `this` 指针赋值，也意味着把this绑定到一个常量的对象上，这使得不能在常量对象上调用普通的成员函数；在 `ClassName` 类的 `const` 成员函数中，`this` 指针的类型为：`const ClassName* const`，这说明不能对 `this` 指针所指向的这种对象是不可修改的（即不能对这种对象的数据成员进行赋值操作）。这样将成员函数声明为const的做法，也有助于提高函数的灵活性。
5. `this` 并不是一个常规变量，而是个右值，所以不能取得 `this` 的地址（不能 `&this`）。
6. 在以下场景中，经常需要显式引用`this`指针：
   1. 为实现对象的链式引用；
   2. 为避免对同一对象进行赋值操作；
   3. 在实现一些数据结构时，如 `list`。

### inline

特征（c++ primer p244）

1. 相当于把内联函数里面的内容写在调用内联函数处;
2. 相当于不用执行进入函数的步骤，直接执行函数体;
3. 相当于宏，却比宏多了类型检查，真正具有函数特性;
4. 编译器一般不内联包含循环、递归、switch等复杂操作的内联函数;
5. 在类声明中定义的函数，除了虚函数的其他函数都会自动隐式地当成内联函数。

### volatile

```volatile int i = 10```

- volatile关键字是一 种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素(操作系统、硬件、其它线程等)更改。所以使用volatile告诉编译器不应对这样的对象进行优化。
- volatile 关键字声明的变量，每次访问时都必须从内存中取出值(没有被volatile修饰的变量，可能由于编译器的优化，从CPU寄存器中取值)
- const可以是volatile (如只读的状态寄存器)
- 指针可以是volatile

### define和typedef

typedef 定义类型的别名，编译阶段有效，有类型检查的功能；有作用域限制

```c++
typedef int* tp;
const tp ptr;    // 此时 ptr 为指针常量，使用 define 则为指向常量的指针
tp ptr1, ptr2;   // 二者都为指针，使用 define 则不是
```

define 是宏定义，发生在预处理阶段，只进行文本替换，不进行任何检查；没有作用域限制

### register

用于指示变量的寄存器优化，现在编译器不太care这个指示，c++11开始标记为废弃，c++17 正式废用。

### explicit

在构造函数前面加explicit阻止类型的隐式转换。explicit只对一个实参的构造函数有效。此外exilicit关键字只能在类内声明构造函数时使用。(P297)

## 指针与引用

1. 指针本身是一个对象，可以进行赋值和拷贝，在生命周期中可以指向多个对象；而引用并非一个对象，只能是一个已经存在的对象的别名，无法令其重新绑定到另一个对象，所以必须进行初始化。
2. 引用不是对象，没有实际地址，所以不能定义指向引用的指针。
3. 可以有自身const指针，但是没有自身是const引用。
4. 指针可以有多级，但是引用只能是一级（int **p；合法 而 int &&a是不合法的）
5. 指针的值可以为空，但是引用的值不能为NULL；
6. 指针的值在初始化后可以改变，即指向其它的存储单元，而引用在进行初始化后就不会再改变了。
7. "sizeof引用"得到的是所指向的变量(对象)的大小，而"sizeof指针"得到的是指针本身的大小；
8. 指针和引用的自增(++)运算意义不一样，指针是对地址的自增，引用是对值的自增；
9. 其它：[引用的底层实现](https://blog.csdn.net/lws123253/article/details/80353197)。

## 面向对象

### 对象内存模型

#### 类的静态成员（static关键字）

静态成员只与类有关系，和对象无关。（p301）

因为静态数据乘员不属于类的任何一个对象，所以衙门并不是在创建类的对象时被定义的。这意味着他们不是由类的构造函数初始化的。而且一般来说，我们不能在类的内部初始化静态成员。相反的，必须在类的外部定义和初始化每个静态成员。和其他对象一样，一个静态数据成员只能定义一次。

### 虚函数

### 构造析构，拷贝控制

#### 构造函数初始值

要善于使用构造函数初始化列表进行初始化，而不是在构造函数中进行赋值。原因有2:

1. 效率问题，如果是赋值进行构造函数的初始化的话，是先初始化，后赋值；相比初始化列表多了一个赋值操作。
2. const成员和引用成员必须使用初始化列表的方式进行。

#### 委托构造函数

使用它所属其他构造函数执行他自己的初始化过程。

### 模版和泛型
